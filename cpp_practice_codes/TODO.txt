1) What is the implementation for the code below regarding the
   conversion from "int pointer" to "InputIterator" and how is
   the comparison done inside the range constructor? (How do
   we know myints + 5 is the end)
int my_ints[]= {10, 20, 30, 40, 50};
std::set<int> second (my_ints, my_ints + 5);

2) Does <vector> contain <utility> ? In one of my codes, this seemed
   to be the case as the compile didn't complain about not including
   <utility> when I put <vector>. If you can't find the answer, ask it
   on stackoverflow.

3) How can we more quickly find the right "other side"? Well, we 
   actually know the other side of (x, ?). It's x + k or x - k.
   If we sorted the array, we could find the other side for each
   of the N elements in 0 (logN) time by doing a binary search.
   
   We now have a two-step algorithm, where both steps take O(N log N)
   time. Now, sorting is the new bottleneck. Optimizing the second 
   step won't help because the first step is slowing us down anyway.

   Cracking the Coding Interview, page 67 (k difference problem).
   
   How is both the sorting part and the binary search part O(NlogN)?

4) Study std::stringstream!

5) Buy/download a git book to learn how to use github properly!

6) How is a struct inside a class is initialized? Such as:
class linked_list {
    private:
    struct node {
        int key;
        node* next;
        node* prev;
    };
};

7) Waymo interview: Hash table, Trees, big(O) notation, trade offs between these!
customer focused
why waymo why this role
queries -> thought process
white board coding
if you were google ceo would you be worried about microsoft
there might be brainteasers?

product design strategy: 

help make technical tradeoffs

estimation questions

AB testing

Understand what it means to be googly!

review google's android principles

google's visual asset guidelines

in the plex steve levy

8) Do the two following expressions give the same result?
   a) if (a == b && c == d)
   b) if ((a == b) && (c == d))

9) Binary search treede bu conditionÄ±n ikincisine niye gerek var
   "while ((pano != NULL) && (cuno == pano->right))"?
   Ans: It is there to end the while loop as soon as we reach
        parent node of the parent node of the value for whose
        successor we are looking for!

        This holds true for the predecessor version as well.
